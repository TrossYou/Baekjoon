<aside>

## 📘 학습한 내용

- 모든 좌표를 시작점으로 고려해야 하는 DFS + DP 완벽 구현
- 문제의 최솟값 조건(최소 1칸 이동)을 활용한 DP 배열 미방문 상태(0)처리
- 조건에 따른 탐색 및 반환 값을 누적(+1)하여 최댓값 갱신
</aside>

## 📝 문제 요약

> - **목표**: N x N 대나무 숲에서 판다가 이동할 수 있는 최대 칸 수 구하기
> - **이동 조건**: 상하좌우 인접한 칸 중, 현재 위치보다 **대나무가 더 많은 칸** 으로만 이동 가능
> - **특징**: 시작점이 정해져 있지 않아, 어느 칸에서 시작했을 때 가장 많이 이동할 수 있는지 모두 탐색해야 함

---

## 💡 1. 나의 접근 방식 & 핵심 아이디어

- **알고리즘/자료구조:** DFS + DP
- **시간/공간 복잡도:**
  - 시간: **O(N^2)**
  - 공간: **O(N^2)**
- **핵심 로직:**
  1. **상태 정의:** `dp[r][c]` = `(r, c)`에서 시작하여 이동할 수 있는 최대 칸 수
  2. **미방문 처리:** 최소 이동 칸 수가 1이므로, 기본 초기값 `0`을 미방문 상태로 활용
  3. **메모이제이션:** `dp[r][c] != 0`일 경우, 이미 계산된 최대 칸 수를 즉시 반환
  4. **탐색 및 갱신:** 상하좌우를 탐색하며 대나무가 더 많은 칸으로 재귀 호출. 반환된 값에 `+ 1`(현재 칸)을 더하여 `Math.max`로 최댓값 갱신
  5. **전체 탐색:** 메인 함수에서 모든 `(i, j)`를 시작점으로 지정해 보고 전체 최댓값(`ans`) 도출

---

## ✨ 2. 나의 최종 코드

### 핵심 구현 코드

- **모든 좌표를 시작점으로 탐색**
  : 판다가 어디서 시작할지 모르기 때문에, 2중 for문으로 모든 칸에서 시작

  ```java
  // 각 칸에서 시작했을 때의 최대 이동 칸 수를 구하고, 전체 최댓값 갱신
      for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
          ans = Math.max(ans, topdownDP(i, j));
        }
      }

      System.out.println(ans);
    }
  ```

- **Top-Down DP 로직**
  : 현재 칸에서 출발하여 갈 수 있는 최대 거리 구하여 저장

  ```jsx
  static int topdownDP(int r, int c) {
      // 1. Memoization: 이미 계산되어 있다면 그대로 반환 (0이 아니면 방문한 것)
      if (dp[r][c] != 0)
        return dp[r][c];

      // 2. 초기값 설정: 현재 칸을 방문했으므로 기본 길이는 1
      int v = map[r][c];
      dp[r][c] = 1;

      // 3. 4방향 탐색
      for (int dir = 0; dir < 4; dir++) {
        int nr = r + dr[dir];
        int nc = c + dc[dir];

        // 맵 범위를 벗어나지 않고, 이전 칸보다 대나무가 많은 경우(이동 가능)
        if (nr >= 0 && nr < N && nc >= 0 && nc < N && map[nr][nc] > v) {
          // 4. 점화식: 현재 저장된 최댓값 vs (다음 칸의 최대 이동 거리 + 현재 칸 1)
          dp[r][c] = Math.max(dp[r][c], topdownDP(nr, nc) + 1);
        }
      }

      return dp[r][c];
    }
  }
  ```

---

## 🤔 3. 문제 회고 (Retrospective)

### 🐾 3-1. 오류 해결 과정 (Troubleshooting Log)

- 1520 문제를 학습 후 풀어서 큰 문제 없었음.
  [내리막 길](https://www.notion.so/31390836b87f804aa7a1edab0add3568?pvs=21)

### **🌱 3-2. 새롭게 알게 된 점 (Learning Points)**

-

### 🧐 3-3. 더 궁금한 점 & 다음 목표 (Further Questions)

- 상하좌우 2차원 격자 DP는 익숙해졌으니, 트리 구조나 비트마스킹을 활용한 DP도 도전하기!
