## 📝 문제 요약

> `N!` 의 값에서 뒤에서부터 0이 아닌 숫자가 나올 때까지 0의 개수를 출력하는 문제
>
> (단, `0≤N≤500`)

---

## 💡 1. 나의 접근 방식 & 핵심 아이디어

- **접근 1: 정직한 시뮬레이션**

  - **알고리즘/자료구조:** `브루트포스(Brute-force)`, `재귀(Recursion)`
  - **시간/공간 복잡도:**
    - **시간 복잡도**: 매우 높음. BigInt를 사용한 큰 수의 곱셈과 나눗셈은 비용이 매우 비쌈. 단순 O(N)이 아님!
    - **공간 복잡도:** O(NlogN) - N!의 결과값을 저장하기 위한 메모리 공간
  - **핵심 로직:**

    1. `N`의 범위가 `500`까지이므로, JavaScript의 `Number` 범위를 초과함.

       -> `BigInt`를 사용해 `N!`의 실제 값을 계산

    2. 계산된 결과값을 `while` 루프를 통해 10으로 더 이상 나누어지지 않을 때까지 반복적으로 나누며 0의 개수를 카운트

- **접근2: 수학적 원리 적용**
  - **알고리즘/자료구조:** 수학
  - **시간/공간 복잡도:**
    - **시간 복잡도:** O(logN)
    - **공간 복잡도:** O(1)
  - **핵심 로직:**
    1. 팩토리얼 값 끝에 있는 `0`의 개수는 **소인수 10의 개수**와 동일함
    2. `10`은 `2*5`로 이루어지며, 팩토리얼 계산 시 소인수 2는 5보다 항상 많음
    3. 따라서 정답은 `N!`을 소인수분해했을 때 `5`의 개수가 몇 개인지와 동일함
    4. `N`까지의 모든 수에 포함된 `5`의 개수를 구하기 위해, N을 `5`의 거듭제곱(5,25,125,...)으로 나눈 몫을 모두 더함
       - 5의 개수 = n / 5. 25의 개수 = n / 25 …

---

## ✨ 2. 나의 최종 코드

```jsx
fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim();
const n = Number(input);

let count = 0;

for (let i = 5; i <= n; i \*= 5) {
    count += Math.floor(n / i);
}
console.log(count);
```

---

## 🤔 3. 문제 회고 (Retrospective)

### 🐾 3-1. 오류 해결 과정 (Trubleshooting Log)

- **1차 시도:** `factorial` 재귀 함수 구현 시, 매개변수 `n`은 `BigInt`로 받았지만, 재귀 호출 시 `n - 1` 과 같이 일반 `Number`와 연산을 시도하여 `TypeError: Cannot mix BigInt and other types` 오류가 발생
  **→ 해결:** `n - 1n`과 같이 숫자 뒤에 `n`을 붙여 `BigInt` 타입으로 통일하여 해결

### **🌱 3-2. 새롭게 알게 된 점 (Learning Points)**

- **문제의 재해석 능력**: “뒤쪽 0의 개수”를 보고 단순히 숫자 계산이 아닌 소인수분해 관점으로도 볼 수 있다!이렇게 단순히 구현만 하는게 아니라, 관점을 바꿔보는 것도 필요하다
- `BigInt`의 비용: `BigInt`는 매우 큰 수를 다룰 수 있지만, `Number`에 비해 상당한 성능 비용이 든다
  → 되도록 `BigInt`를 사용하지 않는게 유리하다
- **시간 복잡도의 중요성:** 브루트포스(`O(NlogN)` 이상) vs `O(logN)`의 성능 차이
